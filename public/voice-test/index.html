<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéôÔ∏è Msosi Voice Assistant</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
            color: #333;
        }

        header {
            background: #212529;
            color: #fff;
            padding: 1rem 2rem;
            text-align: center;
        }

        main {
            max-width: 900px;
            margin: auto;
            padding: 2rem 1rem;
        }

        .chatbox {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 2rem;
        }

        .status {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: #e9ecef;
            font-size: 0.95rem;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .transcription, .recommendation {
            margin-top: 1rem;
            padding: 1rem;
            border-left: 4px solid;
            border-radius: 8px;
        }

        .transcription {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .recommendation {
            background: #fff8e1;
            border-color: #ffc107;
        }

        .product-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }

        .product-card {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .product-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
        }

        .mic-button {
            margin: 1.5rem auto 0;
            display: block;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #f44336;
            color: white;
            font-size: 30px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .mic-button:hover {
            transform: scale(1.05);
        }

        .mic-button:active {
            transform: scale(0.98);
        }

        .mic-button.recording {
            animation: pulse 1.5s infinite;
            background: #4CAF50;
        }

        .recording-status {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #6c757d;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        footer {
            text-align: center;
            font-size: 0.85rem;
            padding: 1rem;
            color: #6c757d;
            margin-top: 2rem;
        }
        
        .hidden {
            display: none;
        }
        
        /* Dietary preferences badges */
        .dietary-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .dietary-badge {
            background: #e9f7ef;
            color: #27ae60;
            padding: 0.3rem 0.7rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        /* Recording tips */
        .recording-tips {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 0.8rem;
            margin: 0.8rem auto;
            max-width: 600px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        .recording-tips ul {
            margin-bottom: 0;
        }
        
        .confidence-indicator {
            display: flex;
            align-items: center;
            margin-top: 0.5rem;
            font-size: 0.8rem;
        }
        
        .confidence-bar {
            flex-grow: 1;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin: 0 8px;
            overflow: hidden;
        }
        
        .confidence-level {
            height: 100%;
            background: #4CAF50;
        }
        
        .confidence-level.low {
            background: #ff6b6b;
        }
        
        .confidence-level.medium {
            background: #ffc107;
        }

        .fallback-options {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: #e9ecef;
            font-size: 0.95rem;
        }

        .category-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .category-btn {
            background: #ffffff;
            border: 1px solid #dee2e6;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }

        .category-btn:hover {
            background: #f0f0f0;
        }

        .text-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .text-input-container input {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .text-input-container button {
            padding: 0.5rem 1rem;
            border: none;
            background: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }

        .text-input-container button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>

<header>
    <h1>üéôÔ∏è Msosi Voice Assistant</h1>
    <p>Say your order ‚Äî "I'd like a veggie burger with fries"</p>
    <div class="recording-tips hidden" id="recordingTips">
        <p><strong>Tips for better results:</strong></p>
        <ul style="text-align: left; display: inline-block; margin: 0 auto; padding-left: 20px;">
            <li>Speak clearly and at a normal pace</li>
            <li>Reduce background noise</li>
            <li>Hold phone/mic closer to your mouth</li>
            <li>Be specific about what food you want</li>
            <li>Try phrases like "I want a burger with cheese" or "Order pizza with pepperoni"</li>
        </ul>
    </div>
</header>

<main>
    <div class="chatbox">
        <div class="status" id="status">Ready to listen for your order.</div>
        
        <button id="micButton" class="mic-button">üé§</button>
        <p id="recordingStatus" class="recording-status">Click to start recording</p>
        
        <div id="transcriptionContainer" class="transcription hidden">
            <strong>Transcription:</strong>
            <p id="transcriptionText"></p>
        </div>

        <div id="recommendationContainer" class="recommendation hidden">
            <strong>AI Recommendation:</strong>
            <p id="recommendationText"></p>
            <div id="dietaryBadges" class="dietary-badges hidden"></div>
        </div>

        <div id="fallbackOptions" class="fallback-options hidden">
            <h3>Popular Categories</h3>
            <div class="category-buttons">
                <button class="category-btn" data-category="burger">Burgers</button>
                <button class="category-btn" data-category="pizza">Pizza</button>
                <button class="category-btn" data-category="vegetarian">Vegetarian</button>
                <button class="category-btn" data-category="chicken">Chicken</button>
                <button class="category-btn" data-category="dessert">Desserts</button>
                <button class="category-btn" data-category="drinks">Drinks</button>
            </div>
            <div class="text-input-container">
                <input type="text" id="manualTextInput" placeholder="Or type your order here...">
                <button id="manualSubmitButton">Search</button>
            </div>
            <div class="retry-container" style="margin-top: 1rem; text-align: center;">
                <button id="retryVoiceButton" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                    üé§ Try Voice Again
                </button>
                <p style="font-size: 0.85rem; margin-top: 0.5rem; color: #666;">
                    Tip: Speak clearly, reduce background noise, and hold the device closer.
                </p>
            </div>
        </div>

        <div id="productsContainer" class="product-list"></div>
    </div>
</main>

<footer>
    Powered by MsosiApp AI ‚Ä¢ JumlaJumla ¬© 2025
</footer>

<script>
    let mediaRecorder, audioChunks = [];
    let isRecording = false;
    let sessionId = 'web-' + Date.now();
    
    const micButton = document.getElementById('micButton');
    const recordingStatus = document.getElementById('recordingStatus');
    const statusEl = document.getElementById('status');
    const transcriptionText = document.getElementById('transcriptionText');
    const transcriptionContainer = document.getElementById('transcriptionContainer');
    const recommendationText = document.getElementById('recommendationText');
    const recommendationContainer = document.getElementById('recommendationContainer');
    const productsContainer = document.getElementById('productsContainer');
    const dietaryBadges = document.getElementById('dietaryBadges');
    const recordingTips = document.getElementById('recordingTips');

    micButton.addEventListener('click', toggleRecording);
    
    // Add event listener for retry button
    document.getElementById('retryVoiceButton').addEventListener('click', function() {
        document.getElementById('fallbackOptions').classList.add('hidden');
        startRecording();
    });
    
    // Add event listeners for category buttons
    document.querySelectorAll('.category-btn').forEach(button => {
        button.addEventListener('click', function() {
            const category = this.dataset.category;
            searchByCategory(category);
        });
    });
    
    // Add event listener for manual text search
    document.getElementById('manualSubmitButton').addEventListener('click', function() {
        const text = document.getElementById('manualTextInput').value.trim();
        if (text) {
            searchByText(text);
        }
    });
    
    function toggleRecording() {
        isRecording ? stopRecording() : startRecording();
    }

    // Check browser compatibility
    function checkBrowserCompatibility() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusEl.textContent = '‚ùå Your browser doesn\'t support voice recording. Please use Chrome, Firefox, or Edge.';
            statusEl.className = 'status error';
            micButton.disabled = true;
            return false;
        }
        return true;
    }
    
    // Initialize the app
    function initApp() {
        if (!checkBrowserCompatibility()) return;
        
        // Check if MediaRecorder supports our desired format
        let supportedMimeType = null;
        const mimeTypes = [
            'audio/webm;codecs=opus',
            'audio/webm',
            'audio/ogg;codecs=opus',
            'audio/wav'
        ];
        
        for (const mimeType of mimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                supportedMimeType = mimeType;
                console.log(`Browser supports ${mimeType}`);
                break;
            }
        }
        
        if (!supportedMimeType) {
            statusEl.textContent = '‚ùå Your browser doesn\'t support required audio formats.';
            statusEl.className = 'status error';
            micButton.disabled = true;
            return;
        }
        
        statusEl.textContent = 'Ready to listen for your order.';
    }
    
    // Call initialization function when page loads
    document.addEventListener('DOMContentLoaded', initApp);

    async function startRecording() {
        try {
            // Reset UI
            transcriptionContainer.classList.add('hidden');
            recommendationContainer.classList.add('hidden');
            dietaryBadges.classList.add('hidden');
            productsContainer.innerHTML = '';
            
            // Show recording tips
            recordingTips.classList.remove('hidden');
            
            // Determine supported MIME type
            // Try to get the best audio format supported by the browser
            let mimeType = 'audio/webm;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'audio/webm';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/ogg;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = '';  // Let browser choose
                    }
                }
            }
            
            console.log('Using audio MIME type:', mimeType || 'browser default');
            
            // Enhanced audio constraints for better voice recognition
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                sampleRate: 16000,          // 16kHz is best for speech recognition
                channelCount: 1,            // Mono for better compatibility with speech recognition
                echoCancellation: true,     // Reduce echo
                noiseSuppression: true,     // Suppress background noise
                autoGainControl: true,      // Auto adjust volume
                latency: 0,                 // Low latency
                googEchoCancellation: true, // Chrome-specific enhancements
                googAutoGainControl: true,
                googNoiseSuppression: true,
              } 
            });
            
            // Set high quality options for better results
            const options = {
              audioBitsPerSecond: 128000, // Higher bitrate = better quality
              bitsPerSecond: 128000      // Overall bitrate
            };
            
            // Add MIME type if supported
            if (mimeType) {
              options.mimeType = mimeType;
              console.log('Using explicit MIME type:', mimeType);
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.onstop = processAudio;
            
            mediaRecorder.start();
            isRecording = true;
            
            micButton.classList.add('recording');
            recordingStatus.textContent = 'Recording... Click to stop';
            statusEl.textContent = 'üéôÔ∏è Listening...';
            statusEl.className = 'status';
        } catch (err) {
            statusEl.textContent = '‚ùå Microphone access denied: ' + err.message;
            statusEl.className = 'status error';
            console.error('Error accessing microphone:', err);
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            
            // Stop all tracks in the stream to release microphone
            if (mediaRecorder.stream) {
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
            
            micButton.classList.remove('recording');
            recordingStatus.textContent = 'Processing...';
            recordingStatus.innerHTML += ' <div class="loader"></div>';
            statusEl.textContent = 'Processing your order...';
        }
    }

    async function processAudio() {
        const mimeType = mediaRecorder.mimeType || 'audio/webm';
        const audioBlob = new Blob(audioChunks, { type: mimeType });

        if (audioBlob.size === 0 || audioBlob.size < 1000) {
            statusEl.textContent = '‚ùå Recording too short or empty. Please try again.';
            statusEl.className = 'status error';
            recordingStatus.textContent = 'Click to start recording';
            return;
        }

        const createFormData = () => {
            const formData = new FormData();
            formData.append('audio', audioBlob, `recording${mimeType.includes('webm') ? '.webm' : '.ogg'}`);
            formData.append('session_id', sessionId);
            formData.append('language', 'en-US');
            return formData;
        };

        try {
            statusEl.textContent = 'Sending audio for processing...';

            const endpoints = [
                '/api/voice/process',
                '/api/voice-dialogue/process',
                '/api/v1/voice-order',
                '/api/voice-test-api'
            ];

            let success = false;
            let data = null;

            for (const endpoint of endpoints) {
                try {
                    const formData = createFormData();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);

                    const response = await fetch(endpoint, {
                        method: 'POST',
                        body: formData,
                        credentials: endpoint.includes('voice-test') ? 'same-origin' : 'include',
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) continue;
                    const json = await response.json();

                    if (json.success || json.transcription || json.text) {
                        data = json;
                        success = true;
                        console.log(`‚úÖ ${endpoint} responded:`, data);
                        break;
                    }
                } catch (err) {
                    console.warn(`‚ö†Ô∏è Error calling ${endpoint}:`, err);
                }
            }

            if (!success || !data) {
                statusEl.textContent = '‚ùå Could not understand your voice. Try again.';
                statusEl.className = 'status error';
                return;
            }

            // ‚úÖ Show transcription
            const transcript = data.transcription || data.text || 'Not recognized';
            transcriptionText.textContent = transcript;
            transcriptionContainer.classList.remove('hidden');

            // ‚úÖ Show fallback if confidence is very low
            const confidence = typeof data.confidence_score === 'number' ? data.confidence_score : 0.7;
            if (confidence < 0.4) {
                fallbackOptions.classList.remove('hidden');
            }

            // ‚úÖ Show recommendation text
            const recommendationMsg =
                data.recommendation_text ||
                data?.openai_analysis?.choices?.[0]?.message?.content ||
                (data.intent_data?.intent ? `You asked about: ${data.intent_data.intent}` : '');

            if (recommendationMsg) {
                recommendationText.textContent = recommendationMsg;
                recommendationContainer.classList.remove('hidden');
            }

            // ‚úÖ Show dietary badges (if any)
            if (Array.isArray(data.dietary_preferences) && data.dietary_preferences.length > 0) {
                displayDietaryPreferences(data.dietary_preferences);
            }

            // ‚úÖ Show products
            if (Array.isArray(data.recommendations) && data.recommendations.length > 0) {
                if (confidence < 0.4) {
                    productsContainer.innerHTML = `<p class="text-center py-4">‚ö†Ô∏è Low confidence in audio. Results may not match. Try again or use buttons below.</p>`;
                }
                displayProducts(data.recommendations);
            } else {
                productsContainer.innerHTML = `<p class="text-center py-4">No products found. Try rephrasing your order.</p>`;
            }

            statusEl.textContent = '‚úÖ Voice processed successfully!';
            statusEl.className = 'status success';
            recordingStatus.textContent = 'Click to start recording';
            recordingTips.classList.add('hidden');

        } catch (e) {
            console.error('Error processing audio:', e);
            statusEl.textContent = `‚ùå ${e.message || 'Error sending audio.'}`;
            statusEl.className = 'status error';
            recordingStatus.textContent = 'Click to start recording';
        }
    }

    function displayProducts(products) {
        productsContainer.innerHTML = '';
        
        products.forEach(p => {
            const card = document.createElement('div');
            card.className = 'product-card';
            
            // Use placeholder if no image
            const img = p.image_url || 'https://via.placeholder.com/150?text=Food';
            
            card.innerHTML = `
                <img src="${img}" alt="${p.name || 'Food'}" />
                <div class="name"><strong>${p.name || 'Item'}</strong></div>
                <div class="price">${p.price ? '$' + parseFloat(p.price).toFixed(2) : ''}</div>
            `;
            
            productsContainer.appendChild(card);
        });
    }
    
    function displayDietaryPreferences(preferences) {
        if (!preferences || preferences.length === 0) return;
        
        dietaryBadges.innerHTML = '';
        dietaryBadges.classList.remove('hidden');
        
        // Display preferences as badges
        preferences.forEach(pref => {
            const badge = document.createElement('span');
            badge.className = 'dietary-badge';
            badge.textContent = formatPreference(pref);
            dietaryBadges.appendChild(badge);
        });
    }
    
    function displayConfidence(score) {
        if (score === undefined) return '';
        
        const confidencePercent = Math.round(score * 100);
        const levelClass = score < 0.5 ? 'low' : score < 0.8 ? 'medium' : 'high';
        
        const container = document.createElement('div');
        container.className = 'confidence-indicator';
        
        container.innerHTML = `
            <span>Confidence:</span>
            <div class="confidence-bar">
                <div class="confidence-level ${levelClass}" style="width: ${confidencePercent}%"></div>
            </div>
            <span>${confidencePercent}%</span>
        `;
        
        return container;
    }
    
    function formatPreference(pref) {
        // Convert preference_key to Preference Key format
        return pref.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
    
    // Function to search by category
    async function searchByCategory(category) {
        statusEl.textContent = 'Searching for ' + category + '...';
        statusEl.className = 'status';
        
        try {
            // Add timeout for the request
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            const response = await fetch('/api/search/category', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    category: category,
                    session_id: sessionId
                }),
                credentials: 'include',
                signal: controller.signal
            });
            
            // Clear the timeout
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error('Server error: ' + response.status);
            }
            
            // Read the JSON data from the response (once)
            const data = await response.json();
            
            if (data.success) {
                // Display recommendations without confidence warnings since this is a direct category selection
                if (data.recommendations && data.recommendations.length > 0) {
                    displayProducts(data.recommendations);
                    statusEl.textContent = '‚úÖ Found ' + data.recommendations.length + ' ' + category + ' items.';
                    statusEl.className = 'status success';
                } else {
                    productsContainer.innerHTML = '<p class="text-center py-4">No items found in the ' + category + ' category.</p>';
                    statusEl.textContent = 'No items found in the ' + category + ' category.';
                }
            } else {
                statusEl.textContent = data.message || '‚ùå Error searching for category.';
                statusEl.className = 'status error';
            }
        } catch (e) {
            console.error('Error searching by category:', e);
            statusEl.textContent = '‚ùå Error: ' + e.message;
            statusEl.className = 'status error';
        }
    }
    
    // Function to search by text input
    async function searchByText(text) {
        statusEl.textContent = 'Searching for "' + text + '"...';
        statusEl.className = 'status';
        
        try {
            // Add timeout for the request
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            const response = await fetch('/api/search/text', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: text,
                    session_id: sessionId
                }),
                credentials: 'include',
                signal: controller.signal
            });
            
            // Clear the timeout
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error('Server error: ' + response.status);
            }
            
            // Read the JSON data from the response (once)
            const data = await response.json();
            
            if (data.success) {
                // Update UI with text search results
                if (data.recommendations && data.recommendations.length > 0) {
                    displayProducts(data.recommendations);
                    statusEl.textContent = '‚úÖ Found ' + data.recommendations.length + ' items matching "' + text + '".';
                    statusEl.className = 'status success';
                } else {
                    productsContainer.innerHTML = '<p class="text-center py-4">No items found matching "' + text + '".</p>';
                    statusEl.textContent = 'No items found matching "' + text + '".';
                }
            } else {
                statusEl.textContent = data.message || '‚ùå Error searching for text.';
                statusEl.className = 'status error';
            }
        } catch (e) {
            console.error('Error searching by text:', e);
            statusEl.textContent = '‚ùå Error: ' + e.message;
            statusEl.className = 'status error';
        }
    }
</script>

</body>
</html>