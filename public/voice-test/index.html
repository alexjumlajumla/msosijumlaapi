<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéôÔ∏è Msosi Voice Assistant</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
            color: #333;
        }

        header {
            background: #212529;
            color: #fff;
            padding: 1rem 2rem;
            text-align: center;
        }

        main {
            max-width: 900px;
            margin: auto;
            padding: 2rem 1rem;
        }

        .chatbox {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 2rem;
        }

        .status {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: #e9ecef;
            font-size: 0.95rem;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .transcription, .recommendation {
            margin-top: 1rem;
            padding: 1rem;
            border-left: 4px solid;
            border-radius: 8px;
        }

        .transcription {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .recommendation {
            background: #fff8e1;
            border-color: #ffc107;
        }

        .product-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }

        .product-card {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .product-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
        }

        .mic-button {
            margin: 1.5rem auto 0;
            display: block;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #f44336;
            color: white;
            font-size: 30px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .mic-button:hover {
            transform: scale(1.05);
        }

        .mic-button:active {
            transform: scale(0.98);
        }

        .mic-button.recording {
            animation: pulse 1.5s infinite;
            background: #4CAF50;
        }

        .recording-status {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #6c757d;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        footer {
            text-align: center;
            font-size: 0.85rem;
            padding: 1rem;
            color: #6c757d;
            margin-top: 2rem;
        }
        
        .hidden {
            display: none;
        }
        
        /* Dietary preferences badges */
        .dietary-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .dietary-badge {
            background: #e9f7ef;
            color: #27ae60;
            padding: 0.3rem 0.7rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        /* Recording tips */
        .recording-tips {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 0.8rem;
            margin: 0.8rem auto;
            max-width: 600px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        .recording-tips ul {
            margin-bottom: 0;
        }
        
        .confidence-indicator {
            display: flex;
            align-items: center;
            margin-top: 0.5rem;
            font-size: 0.8rem;
        }
        
        .confidence-bar {
            flex-grow: 1;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin: 0 8px;
            overflow: hidden;
        }
        
        .confidence-level {
            height: 100%;
            background: #4CAF50;
        }
        
        .confidence-level.low {
            background: #ff6b6b;
        }
        
        .confidence-level.medium {
            background: #ffc107;
        }

        .fallback-options {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: #e9ecef;
            font-size: 0.95rem;
        }

        .category-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .category-btn {
            background: #ffffff;
            border: 1px solid #dee2e6;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }

        .category-btn:hover {
            background: #f0f0f0;
        }

        .text-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .text-input-container input {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .text-input-container button {
            padding: 0.5rem 1rem;
            border: none;
            background: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }

        .text-input-container button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>

<header>
    <h1>üéôÔ∏è Msosi Voice Assistant</h1>
    <p>Say your order ‚Äî "I'd like a veggie burger with fries"</p>
    <div class="recording-tips hidden" id="recordingTips">
        <p><strong>Tips for better results:</strong></p>
        <ul style="text-align: left; display: inline-block; margin: 0 auto; padding-left: 20px;">
            <li>Speak clearly and at a normal pace</li>
            <li>Reduce background noise</li>
            <li>Hold phone/mic closer to your mouth</li>
            <li>Be specific about what food you want</li>
            <li>Try phrases like "I want a burger with cheese" or "Order pizza with pepperoni"</li>
        </ul>
    </div>
</header>

<main>
    <div class="chatbox">
        <div class="status" id="status">Ready to listen for your order.</div>
        
        <button id="micButton" class="mic-button">üé§</button>
        <p id="recordingStatus" class="recording-status">Click to start recording</p>
        
        <div id="transcriptionContainer" class="transcription hidden">
            <strong>Transcription:</strong>
            <p id="transcriptionText"></p>
        </div>

        <div id="recommendationContainer" class="recommendation hidden">
            <strong>AI Recommendation:</strong>
            <p id="recommendationText"></p>
            <div id="dietaryBadges" class="dietary-badges hidden"></div>
        </div>

        <div id="fallbackOptions" class="fallback-options hidden">
            <h3>Popular Categories</h3>
            <div class="category-buttons">
                <button class="category-btn" data-category="burger">Burgers</button>
                <button class="category-btn" data-category="pizza">Pizza</button>
                <button class="category-btn" data-category="vegetarian">Vegetarian</button>
                <button class="category-btn" data-category="chicken">Chicken</button>
                <button class="category-btn" data-category="dessert">Desserts</button>
                <button class="category-btn" data-category="drinks">Drinks</button>
            </div>
            <div class="text-input-container">
                <input type="text" id="manualTextInput" placeholder="Or type your order here...">
                <button id="manualSubmitButton">Search</button>
            </div>
            <div class="retry-container" style="margin-top: 1rem; text-align: center;">
                <button id="retryVoiceButton" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                    üé§ Try Voice Again
                </button>
                <p style="font-size: 0.85rem; margin-top: 0.5rem; color: #666;">
                    Tip: Speak clearly, reduce background noise, and hold the device closer.
                </p>
            </div>
        </div>

        <div id="productsContainer" class="product-list"></div>
    </div>
</main>

<footer>
    Powered by MsosiApp AI ‚Ä¢ JumlaJumla ¬© 2025
</footer>

<script>
    let mediaRecorder, audioChunks = [];
    let isRecording = false;
    let sessionId = 'web-' + Date.now();
    
    const micButton = document.getElementById('micButton');
    const recordingStatus = document.getElementById('recordingStatus');
    const statusEl = document.getElementById('status');
    const transcriptionText = document.getElementById('transcriptionText');
    const transcriptionContainer = document.getElementById('transcriptionContainer');
    const recommendationText = document.getElementById('recommendationText');
    const recommendationContainer = document.getElementById('recommendationContainer');
    const productsContainer = document.getElementById('productsContainer');
    const dietaryBadges = document.getElementById('dietaryBadges');
    const recordingTips = document.getElementById('recordingTips');

    micButton.addEventListener('click', toggleRecording);
    
    // Add event listener for retry button
    document.getElementById('retryVoiceButton').addEventListener('click', function() {
        document.getElementById('fallbackOptions').classList.add('hidden');
        startRecording();
    });
    
    // Add event listeners for category buttons
    document.querySelectorAll('.category-btn').forEach(button => {
        button.addEventListener('click', function() {
            const category = this.dataset.category;
            searchByCategory(category);
        });
    });
    
    // Add event listener for manual text search
    document.getElementById('manualSubmitButton').addEventListener('click', function() {
        const text = document.getElementById('manualTextInput').value.trim();
        if (text) {
            searchByText(text);
        }
    });
    
    function toggleRecording() {
        isRecording ? stopRecording() : startRecording();
    }

    // Check browser compatibility
    function checkBrowserCompatibility() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusEl.textContent = '‚ùå Your browser doesn\'t support voice recording. Please use Chrome, Firefox, or Edge.';
            statusEl.className = 'status error';
            micButton.disabled = true;
            return false;
        }
        return true;
    }
    
    // Initialize the app
    function initApp() {
        if (!checkBrowserCompatibility()) return;
        
        // Check if MediaRecorder supports our desired format
        let supportedMimeType = null;
        const mimeTypes = [
            'audio/webm;codecs=opus',
            'audio/webm',
            'audio/ogg;codecs=opus',
            'audio/wav'
        ];
        
        for (const mimeType of mimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                supportedMimeType = mimeType;
                console.log(`Browser supports ${mimeType}`);
                break;
            }
        }
        
        if (!supportedMimeType) {
            statusEl.textContent = '‚ùå Your browser doesn\'t support required audio formats.';
            statusEl.className = 'status error';
            micButton.disabled = true;
            return;
        }
        
        statusEl.textContent = 'Ready to listen for your order.';
    }
    
    // Call initialization function when page loads
    document.addEventListener('DOMContentLoaded', initApp);

    async function startRecording() {
        try {
            // Reset UI
            transcriptionContainer.classList.add('hidden');
            recommendationContainer.classList.add('hidden');
            dietaryBadges.classList.add('hidden');
            productsContainer.innerHTML = '';
            
            // Show recording tips
            recordingTips.classList.remove('hidden');
            
            // Determine supported MIME type
            let mimeType = 'audio/webm;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'audio/webm';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/ogg;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = '';  // Let browser choose
                    }
                }
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                sampleRate: 16000,
                channelCount: 1,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
              } 
            });
            
            const options = {
              audioBitsPerSecond: 128000  // Increased bit rate for better quality
            };
            
            if (mimeType) {
              options.mimeType = mimeType;
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.onstop = processAudio;
            
            mediaRecorder.start();
            isRecording = true;
            
            micButton.classList.add('recording');
            recordingStatus.textContent = 'Recording... Click to stop';
            statusEl.textContent = 'üéôÔ∏è Listening...';
            statusEl.className = 'status';
        } catch (err) {
            statusEl.textContent = '‚ùå Microphone access denied: ' + err.message;
            statusEl.className = 'status error';
            console.error('Error accessing microphone:', err);
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            
            // Stop all tracks in the stream to release microphone
            if (mediaRecorder.stream) {
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
            
            micButton.classList.remove('recording');
            recordingStatus.textContent = 'Processing...';
            recordingStatus.innerHTML += ' <div class="loader"></div>';
            statusEl.textContent = 'Processing your order...';
        }
    }

    async function processAudio() {
        // Get mime type from mediaRecorder
        const mimeType = mediaRecorder.mimeType || 'audio/webm';
        const audioBlob = new Blob(audioChunks, { type: mimeType });
        
        // Log audio details for debugging
        console.log(`Recording complete: ${(audioBlob.size / 1024).toFixed(2)} KB, MIME type: ${mimeType}`);
        
        const formData = new FormData();
        formData.append('audio', audioBlob, `recording${mimeType.includes('webm') ? '.webm' : mimeType.includes('ogg') ? '.ogg' : '.wav'}`);
        formData.append('session_id', sessionId);
        formData.append('language', 'en-US'); // Hard-code to en-US for better compatibility

        try {
            statusEl.textContent = 'Sending audio for processing...';
            
            // Completely redesigned endpoint fallback system to avoid response stream issues
            let data = null;
            const endpoints = [
                {
                    url: '/api/voice/process',
                    options: {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    },
                    name: 'Primary endpoint'
                },
                {
                    url: '/api/voice-dialogue/process',
                    options: {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    },
                    name: 'Voice dialogue endpoint'
                },
                {
                    url: '/api/v1/voice-order',
                    options: {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    },
                    name: 'V1 REST API endpoint'
                },
                {
                    url: '/api/voice-test-api',
                    options: {
                        method: 'POST',
                        body: formData
                    },
                    name: 'Test API endpoint'
                }
            ];
            
            // Try each endpoint until one works
            for (const endpoint of endpoints) {
                try {
                    console.log(`Trying ${endpoint.name}...`);
                    const response = await fetch(endpoint.url, endpoint.options);
                    
                    if (!response.ok) {
                        console.warn(`${endpoint.name} returned status ${response.status}`);
                        continue; // Try next endpoint
                    }
                    
                    // Successfully got a response, parse it
                    data = await response.json();
                    
                    // First, check for valid data
                    if (data && (data.success || (data.transcription || data.text))) {
                        console.log(`${endpoint.name} succeeded`, data);
                        break; // Exit the loop with valid data
                    } else {
                        console.warn(`${endpoint.name} returned invalid data format`, data);
                        // If we got invalid data format, keep trying next endpoints
                    }
                } catch (err) {
                    console.warn(`${endpoint.name} failed:`, err.message);
                    // Continue to next endpoint
                }
            }
            
            // If all endpoints failed, throw an error
            if (!data) {
                throw new Error('All API endpoints failed');
            }

            if (data.success) {
                // Hide recording tips when we have results
                recordingTips.classList.add('hidden');
                
                // Display transcription even if confidence is low
                transcriptionText.textContent = data.transcription || data.text || 'N/A';
                transcriptionContainer.classList.remove('hidden');
                
                // Add confidence indicator if available
                if (data.confidence_score !== undefined) {
                    const confidenceEl = displayConfidence(data.confidence_score);
                    transcriptionContainer.appendChild(confidenceEl);
                    
                    // If confidence is low, show a hint to the user
                    if (data.confidence_score < 0.7) {
                        const hint = document.createElement('p');
                        hint.innerHTML = '<small style="color:#ff6b6b">Tip: Speak clearly and reduce background noise for better results.</small>';
                        transcriptionContainer.appendChild(hint);
                    }
                }
                
                // Weigh recommendations based on confidence before displaying
                const confidenceScore = data.confidence_score !== undefined ? data.confidence_score : 0.5;
                const fallbackOptions = document.getElementById('fallbackOptions');
                
                // Handle based on confidence tiers
                if (confidenceScore < 0.4) {
                    // Very low confidence - show fallback UI
                    fallbackOptions.classList.remove('hidden');
                    recommendationText.textContent = "I couldn't clearly understand your request. Please try speaking more clearly, or use one of the options below.";
                    recommendationContainer.classList.remove('hidden');
                } else if (confidenceScore < 0.7) {
                    // Medium confidence - show recommendations but with caution message
                    if (data.recommendation_text) {
                        recommendationText.textContent = data.recommendation_text + "\n\n(Note: I'm not completely confident I understood correctly. Please confirm if this matches your request.)";
                        recommendationContainer.classList.remove('hidden');
                    } else if (data.openai_analysis) {
                        // Handle test API format
                        const messageContent = data.openai_analysis.choices[0].message.content;
                        recommendationText.textContent = messageContent + "\n\n(Note: I'm not completely confident I understood correctly. Please confirm if this matches your request.)";
                        recommendationContainer.classList.remove('hidden');
                    }
                } else {
                    // High confidence - show recommendations normally
                    if (data.recommendation_text) {
                        recommendationText.textContent = data.recommendation_text;
                        recommendationContainer.classList.remove('hidden');
                    } else if (data.openai_analysis) {
                        // Handle test API format
                        const messageContent = data.openai_analysis.choices[0].message.content;
                        recommendationText.textContent = messageContent;
                        recommendationContainer.classList.remove('hidden');
                    } else {
                        // If no recommendation is provided but we have transcription,
                        // show a generic message
                        recommendationText.textContent = "I understood your request but couldn't generate specific recommendations. Try being more specific about what food you're looking for.";
                        recommendationContainer.classList.remove('hidden');
                    }
                }
                
                // Display dietary preferences if any
                if (data.dietary_preferences && data.dietary_preferences.length > 0) {
                    displayDietaryPreferences(data.dietary_preferences);
                }
                
                // Display product recommendations based on confidence score
                if (data.recommendations && data.recommendations.length > 0) {
                    const confidenceScore = data.confidence_score !== undefined ? data.confidence_score : 0.5;
                    
                    if (confidenceScore < 0.4) {
                        // Very low confidence - don't show potentially incorrect recommendations
                        productsContainer.innerHTML = '<p class="text-center py-4">Could not generate reliable recommendations due to unclear audio. Please try again or use the options above.</p>';
                    } else if (confidenceScore < 0.7) {
                        // Medium confidence - show recommendations with disclaimer
                        productsContainer.innerHTML = '<p style="color: #ff9800; text-align: center; margin-bottom: 1rem;">‚ö†Ô∏è These recommendations are based on what I think I heard. They might not be exactly what you wanted.</p>';
                        displayProducts(data.recommendations);
                    } else {
                        // High confidence - show recommendations normally
                        displayProducts(data.recommendations);
                    }
                } else if (data.transcription || data.text) {
                    // If we have transcription but no recommendations, show a message
                    productsContainer.innerHTML = '<p class="text-center py-4">No specific product recommendations found. Try being more specific about what you\'re looking for.</p>';
                }
                
                statusEl.textContent = '‚úÖ Voice processed successfully!';
                statusEl.className = 'status success';
            } else {
                // Show specific error messages based on error type
                if (data.message && data.message.includes("sample rate")) {
                    statusEl.textContent = '‚ùå Audio format error. Please try again. Technical details: ' + data.message;
                } else if (data.message && data.message.includes("No voice text")) {
                    statusEl.textContent = '‚ùå Could not understand speech. Please speak clearly and try again.';
                } else {
                    statusEl.textContent = data.message || '‚ùå Something went wrong.';
                }
                statusEl.className = 'status error';
            }
            
            // Reset recording status
            recordingStatus.textContent = 'Click to start recording';
            
        } catch (e) {
            console.error('Error processing audio:', e);
            statusEl.textContent = '‚ùå Network or server error: ' + e.message;
            statusEl.className = 'status error';
            recordingStatus.textContent = 'Click to start recording';
        }
    }

    function displayProducts(products) {
        productsContainer.innerHTML = '';
        
        products.forEach(p => {
            const card = document.createElement('div');
            card.className = 'product-card';
            
            // Use placeholder if no image
            const img = p.image_url || 'https://via.placeholder.com/150?text=Food';
            
            card.innerHTML = `
                <img src="${img}" alt="${p.name || 'Food'}" />
                <div class="name"><strong>${p.name || 'Item'}</strong></div>
                <div class="price">${p.price ? '$' + parseFloat(p.price).toFixed(2) : ''}</div>
            `;
            
            productsContainer.appendChild(card);
        });
    }
    
    function displayDietaryPreferences(preferences) {
        if (!preferences || preferences.length === 0) return;
        
        dietaryBadges.innerHTML = '';
        dietaryBadges.classList.remove('hidden');
        
        // Display preferences as badges
        preferences.forEach(pref => {
            const badge = document.createElement('span');
            badge.className = 'dietary-badge';
            badge.textContent = formatPreference(pref);
            dietaryBadges.appendChild(badge);
        });
    }
    
    function displayConfidence(score) {
        if (score === undefined) return '';
        
        const confidencePercent = Math.round(score * 100);
        const levelClass = score < 0.5 ? 'low' : score < 0.8 ? 'medium' : 'high';
        
        const container = document.createElement('div');
        container.className = 'confidence-indicator';
        
        container.innerHTML = `
            <span>Confidence:</span>
            <div class="confidence-bar">
                <div class="confidence-level ${levelClass}" style="width: ${confidencePercent}%"></div>
            </div>
            <span>${confidencePercent}%</span>
        `;
        
        return container;
    }
    
    function formatPreference(pref) {
        // Convert preference_key to Preference Key format
        return pref.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
    
    // Function to search by category
    async function searchByCategory(category) {
        statusEl.textContent = 'Searching for ' + category + '...';
        statusEl.className = 'status';
        
        try {
            const response = await fetch('/api/search/category', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    category: category,
                    session_id: sessionId
                }),
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('Server error: ' + response.status);
            }
            
            // Clone response before reading it
            const responseClone = response.clone();
            let data;
            
            try {
                data = await response.json();
            } catch (err) {
                console.warn('Failed to parse category search JSON, trying clone:', err);
                data = await responseClone.json();
            }
            
            if (data.success) {
                // Display recommendations without confidence warnings since this is a direct category selection
                if (data.recommendations && data.recommendations.length > 0) {
                    displayProducts(data.recommendations);
                    statusEl.textContent = '‚úÖ Found ' + data.recommendations.length + ' ' + category + ' items.';
                    statusEl.className = 'status success';
                } else {
                    productsContainer.innerHTML = '<p class="text-center py-4">No items found in the ' + category + ' category.</p>';
                    statusEl.textContent = 'No items found in the ' + category + ' category.';
                }
            } else {
                statusEl.textContent = data.message || '‚ùå Error searching for category.';
                statusEl.className = 'status error';
            }
        } catch (e) {
            console.error('Error searching by category:', e);
            statusEl.textContent = '‚ùå Error: ' + e.message;
            statusEl.className = 'status error';
        }
    }
    
    // Function to search by text input
    async function searchByText(text) {
        statusEl.textContent = 'Searching for "' + text + '"...';
        statusEl.className = 'status';
        
        try {
            const response = await fetch('/api/search/text', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: text,
                    session_id: sessionId
                }),
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error('Server error: ' + response.status);
            }
            
            // Clone response before reading it
            const responseClone = response.clone();
            let data;
            
            try {
                data = await response.json();
            } catch (err) {
                console.warn('Failed to parse text search JSON, trying clone:', err);
                data = await responseClone.json();
            }
            
            if (data.success) {
                // Update UI with text search results
                if (data.recommendations && data.recommendations.length > 0) {
                    displayProducts(data.recommendations);
                    statusEl.textContent = '‚úÖ Found ' + data.recommendations.length + ' items matching "' + text + '".';
                    statusEl.className = 'status success';
                } else {
                    productsContainer.innerHTML = '<p class="text-center py-4">No items found matching "' + text + '".</p>';
                    statusEl.textContent = 'No items found matching "' + text + '".';
                }
            } else {
                statusEl.textContent = data.message || '‚ùå Error searching for text.';
                statusEl.className = 'status error';
            }
        } catch (e) {
            console.error('Error searching by text:', e);
            statusEl.textContent = '‚ùå Error: ' + e.message;
            statusEl.className = 'status error';
        }
    }
</script>

</body>
</html>