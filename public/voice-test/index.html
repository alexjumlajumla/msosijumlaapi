<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéôÔ∏è Msosi Voice Assistant</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
            color: #333;
        }

        header {
            background: #212529;
            color: #fff;
            padding: 1rem 2rem;
            text-align: center;
        }

        main {
            max-width: 900px;
            margin: auto;
            padding: 2rem 1rem;
        }

        .chatbox {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 2rem;
        }

        .status {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: #e9ecef;
            font-size: 0.95rem;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .transcription, .recommendation {
            margin-top: 1rem;
            padding: 1rem;
            border-left: 4px solid;
            border-radius: 8px;
        }

        .transcription {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .recommendation {
            background: #fff8e1;
            border-color: #ffc107;
        }

        .product-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }

        .product-card {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .product-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
        }

        .mic-button {
            margin: 1.5rem auto 0;
            display: block;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #f44336;
            color: white;
            font-size: 30px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .mic-button:hover {
            transform: scale(1.05);
        }

        .mic-button:active {
            transform: scale(0.98);
        }

        .mic-button.recording {
            animation: pulse 1.5s infinite;
            background: #4CAF50;
        }

        .recording-status {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #6c757d;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        footer {
            text-align: center;
            font-size: 0.85rem;
            padding: 1rem;
            color: #6c757d;
            margin-top: 2rem;
        }
        
        .hidden {
            display: none;
        }
        
        /* Dietary preferences badges */
        .dietary-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .dietary-badge {
            background: #e9f7ef;
            color: #27ae60;
            padding: 0.3rem 0.7rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 500;
        }
    </style>
</head>
<body>

<header>
    <h1>üéôÔ∏è Msosi Voice Assistant</h1>
    <p>Say your order ‚Äî "I'd like a veggie burger with fries"</p>
</header>

<main>
    <div class="chatbox">
        <div class="status" id="status">Ready to listen for your order.</div>
        
        <button id="micButton" class="mic-button">üé§</button>
        <p id="recordingStatus" class="recording-status">Click to start recording</p>
        
        <div id="transcriptionContainer" class="transcription hidden">
            <strong>Transcription:</strong>
            <p id="transcriptionText"></p>
        </div>

        <div id="recommendationContainer" class="recommendation hidden">
            <strong>AI Recommendation:</strong>
            <p id="recommendationText"></p>
            <div id="dietaryBadges" class="dietary-badges hidden"></div>
        </div>

        <div id="productsContainer" class="product-list"></div>
    </div>
</main>

<footer>
    Powered by MsosiApp AI ‚Ä¢ JumlaJumla ¬© 2025
</footer>

<script>
    let mediaRecorder, audioChunks = [];
    let isRecording = false;
    let sessionId = 'web-' + Date.now();
    
    const micButton = document.getElementById('micButton');
    const recordingStatus = document.getElementById('recordingStatus');
    const statusEl = document.getElementById('status');
    const transcriptionText = document.getElementById('transcriptionText');
    const transcriptionContainer = document.getElementById('transcriptionContainer');
    const recommendationText = document.getElementById('recommendationText');
    const recommendationContainer = document.getElementById('recommendationContainer');
    const productsContainer = document.getElementById('productsContainer');
    const dietaryBadges = document.getElementById('dietaryBadges');

    micButton.addEventListener('click', toggleRecording);

    function toggleRecording() {
        isRecording ? stopRecording() : startRecording();
    }

    // Check browser compatibility
    function checkBrowserCompatibility() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusEl.textContent = '‚ùå Your browser doesn\'t support voice recording. Please use Chrome, Firefox, or Edge.';
            statusEl.className = 'status error';
            micButton.disabled = true;
            return false;
        }
        return true;
    }
    
    // Initialize the app
    function initApp() {
        if (!checkBrowserCompatibility()) return;
        
        // Check if MediaRecorder supports our desired format
        let supportedMimeType = null;
        const mimeTypes = [
            'audio/webm;codecs=opus',
            'audio/webm',
            'audio/ogg;codecs=opus',
            'audio/wav'
        ];
        
        for (const mimeType of mimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                supportedMimeType = mimeType;
                console.log(`Browser supports ${mimeType}`);
                break;
            }
        }
        
        if (!supportedMimeType) {
            statusEl.textContent = '‚ùå Your browser doesn\'t support required audio formats.';
            statusEl.className = 'status error';
            micButton.disabled = true;
            return;
        }
        
        statusEl.textContent = 'Ready to listen for your order.';
    }
    
    // Call initialization function when page loads
    document.addEventListener('DOMContentLoaded', initApp);

    async function startRecording() {
        try {
            // Reset UI
            transcriptionContainer.classList.add('hidden');
            recommendationContainer.classList.add('hidden');
            dietaryBadges.classList.add('hidden');
            productsContainer.innerHTML = '';
            
            // Determine supported MIME type
            let mimeType = 'audio/webm;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'audio/webm';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/ogg;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = '';  // Let browser choose
                    }
                }
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({ audio: {
                sampleRate: 16000,
                channelCount: 1,
                echoCancellation: true,
                noiseSuppression: true
            }});
            
            const options = {
                audioBitsPerSecond: 16000
            };
            
            if (mimeType) {
                options.mimeType = mimeType;
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.onstop = processAudio;
            
            mediaRecorder.start();
            isRecording = true;
            
            micButton.classList.add('recording');
            recordingStatus.textContent = 'Recording... Click to stop';
            statusEl.textContent = 'üéôÔ∏è Listening...';
            statusEl.className = 'status';
        } catch (err) {
            statusEl.textContent = '‚ùå Microphone access denied: ' + err.message;
            statusEl.className = 'status error';
            console.error('Error accessing microphone:', err);
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            
            micButton.classList.remove('recording');
            recordingStatus.textContent = 'Processing...';
            recordingStatus.innerHTML += ' <div class="loader"></div>';
            statusEl.textContent = 'Processing your order...';
        }
    }

    async function processAudio() {
        // Get mime type from mediaRecorder
        const mimeType = mediaRecorder.mimeType || 'audio/webm';
        const audioBlob = new Blob(audioChunks, { type: mimeType });
        
        // Log audio details for debugging
        console.log(`Recording complete: ${(audioBlob.size / 1024).toFixed(2)} KB, MIME type: ${mimeType}`);
        
        const formData = new FormData();
        formData.append('audio', audioBlob, `recording${mimeType.includes('webm') ? '.webm' : mimeType.includes('ogg') ? '.ogg' : '.wav'}`);
        formData.append('session_id', sessionId);
        formData.append('language', 'en-US'); // Hard-code to en-US for better compatibility

        try {
            statusEl.textContent = 'Sending audio for processing...';
            
            // Try multiple endpoints in sequence to improve reliability
            let response = null;
            let error = null;
            let responseData = null;
            
            // Try each endpoint in order until one works
            try {
                response = await fetch('/api/voice/process', {
                    method: 'POST',
                    body: formData,
                    credentials: 'include'
                });
                
                responseData = await response.json();
                console.log('Primary endpoint succeeded', responseData);
                
                // Check for transcription errors
                if (!responseData.success && responseData.message && responseData.message.includes("No voice text could be extracted")) {
                    throw new Error(responseData.message || "Could not transcribe audio");
                }
                
            } catch (err) {
                console.warn('Primary endpoint failed:', err);
                error = err;
                response = null;
            }
            
            // If primary failed, try the voice-dialogue endpoint
            if (!response) {
                try {
                    response = await fetch('/api/voice-dialogue/process', {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    });
                    console.log('Voice-dialogue endpoint succeeded');
                } catch (err) {
                    console.warn('Voice-dialogue endpoint failed:', err);
                    error = err;
                }
            }
            
            // If both failed, try the v1 endpoint in the REST API
            if (!response) {
                try {
                    response = await fetch('/api/v1/voice-order', {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    });
                    console.log('V1 endpoint succeeded');
                } catch (err) {
                    console.warn('V1 endpoint failed:', err);
                    error = err;
                }
            }
            
            // If all API endpoints failed, try the test endpoint
            if (!response) {
                try {
                    response = await fetch('/api/voice-test-api', {
                        method: 'POST',
                        body: formData
                    });
                    console.log('Test endpoint succeeded');
                } catch (err) {
                    console.warn('Test endpoint failed:', err);
                    error = err;
                }
            }
            
            // If all endpoints failed, show error
            if (!response) {
                throw new Error('All API endpoints failed: ' + (error ? error.message : 'Unknown error'));
            }
            
            const data = await response.json();

            if (data.success) {
                // Display transcription
                transcriptionText.textContent = data.transcription || data.text || 'N/A';
                transcriptionContainer.classList.remove('hidden');
                
                // Display recommendation
                if (data.recommendation_text) {
                    recommendationText.textContent = data.recommendation_text;
                    recommendationContainer.classList.remove('hidden');
                } else if (data.openai_analysis) {
                    // Handle test API format
                    const messageContent = data.openai_analysis.choices[0].message.content;
                    recommendationText.textContent = messageContent;
                    recommendationContainer.classList.remove('hidden');
                }
                
                // Display dietary preferences if any
                if (data.dietary_preferences && data.dietary_preferences.length > 0) {
                    displayDietaryPreferences(data.dietary_preferences);
                }
                
                // Display product recommendations
                if (data.recommendations && data.recommendations.length > 0) {
                    displayProducts(data.recommendations);
                }
                
                statusEl.textContent = '‚úÖ Voice order processed successfully!';
                statusEl.className = 'status success';
            } else {
                // Show specific error messages based on error type
                if (data.message && data.message.includes("sample rate")) {
                    statusEl.textContent = '‚ùå Audio format error. Please try again. Technical details: ' + data.message;
                } else if (data.message && data.message.includes("No voice text")) {
                    statusEl.textContent = '‚ùå Could not understand speech. Please speak clearly and try again.';
                } else {
                    statusEl.textContent = data.message || '‚ùå Something went wrong.';
                }
                statusEl.className = 'status error';
            }
            
            // Reset recording status
            recordingStatus.textContent = 'Click to start recording';
            
        } catch (e) {
            console.error('Error processing audio:', e);
            statusEl.textContent = '‚ùå Network or server error: ' + e.message;
            statusEl.className = 'status error';
            recordingStatus.textContent = 'Click to start recording';
        }
    }

    function displayProducts(products) {
        productsContainer.innerHTML = '';
        
        products.forEach(p => {
            const card = document.createElement('div');
            card.className = 'product-card';
            
            // Use placeholder if no image
            const img = p.image_url || 'https://via.placeholder.com/150?text=Food';
            
            card.innerHTML = `
                <img src="${img}" alt="${p.name || 'Food'}" />
                <div class="name"><strong>${p.name || 'Item'}</strong></div>
                <div class="price">${p.price ? '$' + parseFloat(p.price).toFixed(2) : ''}</div>
            `;
            
            productsContainer.appendChild(card);
        });
    }
    
    function displayDietaryPreferences(preferences) {
        if (!preferences || preferences.length === 0) return;
        
        dietaryBadges.innerHTML = '';
        dietaryBadges.classList.remove('hidden');
        
        // Display preferences as badges
        preferences.forEach(pref => {
            const badge = document.createElement('span');
            badge.className = 'dietary-badge';
            badge.textContent = formatPreference(pref);
            dietaryBadges.appendChild(badge);
        });
    }
    
    function formatPreference(pref) {
        // Convert preference_key to Preference Key format
        return pref.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
</script>

</body>
</html>